// Autogenerated by Thrift Compiler (0.9.3)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package main

import (
	"flag"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
	"math"
	"net"
	"net/url"
	"os"
	"proxy"
	"strconv"
	"strings"
)

func Usage() {
	fmt.Fprintln(os.Stderr, "Usage of ", os.Args[0], " [-h host:port] [-u url] [-f[ramed]] function [arg1 [arg2...]]:")
	flag.PrintDefaults()
	fmt.Fprintln(os.Stderr, "\nFunctions:")
	fmt.Fprintln(os.Stderr, "  string login(string principal,  loginProperties)")
	fmt.Fprintln(os.Stderr, "  i32 addConstraint(string login, string tableName, string constraintClassName)")
	fmt.Fprintln(os.Stderr, "  void addSplits(string login, string tableName,  splits)")
	fmt.Fprintln(os.Stderr, "  void attachIterator(string login, string tableName, IteratorSetting setting,  scopes)")
	fmt.Fprintln(os.Stderr, "  void checkIteratorConflicts(string login, string tableName, IteratorSetting setting,  scopes)")
	fmt.Fprintln(os.Stderr, "  void clearLocatorCache(string login, string tableName)")
	fmt.Fprintln(os.Stderr, "  void cloneTable(string login, string tableName, string newTableName, bool flush,  propertiesToSet,  propertiesToExclude)")
	fmt.Fprintln(os.Stderr, "  void compactTable(string login, string tableName, string startRow, string endRow,  iterators, bool flush, bool wait, CompactionStrategyConfig compactionStrategy)")
	fmt.Fprintln(os.Stderr, "  void cancelCompaction(string login, string tableName)")
	fmt.Fprintln(os.Stderr, "  void createTable(string login, string tableName, bool versioningIter, TimeType type)")
	fmt.Fprintln(os.Stderr, "  void deleteTable(string login, string tableName)")
	fmt.Fprintln(os.Stderr, "  void deleteRows(string login, string tableName, string startRow, string endRow)")
	fmt.Fprintln(os.Stderr, "  void exportTable(string login, string tableName, string exportDir)")
	fmt.Fprintln(os.Stderr, "  void flushTable(string login, string tableName, string startRow, string endRow, bool wait)")
	fmt.Fprintln(os.Stderr, "   getDiskUsage(string login,  tables)")
	fmt.Fprintln(os.Stderr, "   getLocalityGroups(string login, string tableName)")
	fmt.Fprintln(os.Stderr, "  IteratorSetting getIteratorSetting(string login, string tableName, string iteratorName, IteratorScope scope)")
	fmt.Fprintln(os.Stderr, "  string getMaxRow(string login, string tableName,  auths, string startRow, bool startInclusive, string endRow, bool endInclusive)")
	fmt.Fprintln(os.Stderr, "   getTableProperties(string login, string tableName)")
	fmt.Fprintln(os.Stderr, "  void importDirectory(string login, string tableName, string importDir, string failureDir, bool setTime)")
	fmt.Fprintln(os.Stderr, "  void importTable(string login, string tableName, string importDir)")
	fmt.Fprintln(os.Stderr, "   listSplits(string login, string tableName, i32 maxSplits)")
	fmt.Fprintln(os.Stderr, "   listTables(string login)")
	fmt.Fprintln(os.Stderr, "   listIterators(string login, string tableName)")
	fmt.Fprintln(os.Stderr, "   listConstraints(string login, string tableName)")
	fmt.Fprintln(os.Stderr, "  void mergeTablets(string login, string tableName, string startRow, string endRow)")
	fmt.Fprintln(os.Stderr, "  void offlineTable(string login, string tableName, bool wait)")
	fmt.Fprintln(os.Stderr, "  void onlineTable(string login, string tableName, bool wait)")
	fmt.Fprintln(os.Stderr, "  void removeConstraint(string login, string tableName, i32 constraint)")
	fmt.Fprintln(os.Stderr, "  void removeIterator(string login, string tableName, string iterName,  scopes)")
	fmt.Fprintln(os.Stderr, "  void removeTableProperty(string login, string tableName, string property)")
	fmt.Fprintln(os.Stderr, "  void renameTable(string login, string oldTableName, string newTableName)")
	fmt.Fprintln(os.Stderr, "  void setLocalityGroups(string login, string tableName,  groups)")
	fmt.Fprintln(os.Stderr, "  void setTableProperty(string login, string tableName, string property, string value)")
	fmt.Fprintln(os.Stderr, "   splitRangeByTablets(string login, string tableName, Range range, i32 maxSplits)")
	fmt.Fprintln(os.Stderr, "  bool tableExists(string login, string tableName)")
	fmt.Fprintln(os.Stderr, "   tableIdMap(string login)")
	fmt.Fprintln(os.Stderr, "  bool testTableClassLoad(string login, string tableName, string className, string asTypeName)")
	fmt.Fprintln(os.Stderr, "  void pingTabletServer(string login, string tserver)")
	fmt.Fprintln(os.Stderr, "   getActiveScans(string login, string tserver)")
	fmt.Fprintln(os.Stderr, "   getActiveCompactions(string login, string tserver)")
	fmt.Fprintln(os.Stderr, "   getSiteConfiguration(string login)")
	fmt.Fprintln(os.Stderr, "   getSystemConfiguration(string login)")
	fmt.Fprintln(os.Stderr, "   getTabletServers(string login)")
	fmt.Fprintln(os.Stderr, "  void removeProperty(string login, string property)")
	fmt.Fprintln(os.Stderr, "  void setProperty(string login, string property, string value)")
	fmt.Fprintln(os.Stderr, "  bool testClassLoad(string login, string className, string asTypeName)")
	fmt.Fprintln(os.Stderr, "  bool authenticateUser(string login, string user,  properties)")
	fmt.Fprintln(os.Stderr, "  void changeUserAuthorizations(string login, string user,  authorizations)")
	fmt.Fprintln(os.Stderr, "  void changeLocalUserPassword(string login, string user, string password)")
	fmt.Fprintln(os.Stderr, "  void createLocalUser(string login, string user, string password)")
	fmt.Fprintln(os.Stderr, "  void dropLocalUser(string login, string user)")
	fmt.Fprintln(os.Stderr, "   getUserAuthorizations(string login, string user)")
	fmt.Fprintln(os.Stderr, "  void grantSystemPermission(string login, string user, SystemPermission perm)")
	fmt.Fprintln(os.Stderr, "  void grantTablePermission(string login, string user, string table, TablePermission perm)")
	fmt.Fprintln(os.Stderr, "  bool hasSystemPermission(string login, string user, SystemPermission perm)")
	fmt.Fprintln(os.Stderr, "  bool hasTablePermission(string login, string user, string table, TablePermission perm)")
	fmt.Fprintln(os.Stderr, "   listLocalUsers(string login)")
	fmt.Fprintln(os.Stderr, "  void revokeSystemPermission(string login, string user, SystemPermission perm)")
	fmt.Fprintln(os.Stderr, "  void revokeTablePermission(string login, string user, string table, TablePermission perm)")
	fmt.Fprintln(os.Stderr, "  string createBatchScanner(string login, string tableName, BatchScanOptions options)")
	fmt.Fprintln(os.Stderr, "  string createScanner(string login, string tableName, ScanOptions options)")
	fmt.Fprintln(os.Stderr, "  bool hasNext(string scanner)")
	fmt.Fprintln(os.Stderr, "  KeyValueAndPeek nextEntry(string scanner)")
	fmt.Fprintln(os.Stderr, "  ScanResult nextK(string scanner, i32 k)")
	fmt.Fprintln(os.Stderr, "  void closeScanner(string scanner)")
	fmt.Fprintln(os.Stderr, "  void updateAndFlush(string login, string tableName,  cells)")
	fmt.Fprintln(os.Stderr, "  string createWriter(string login, string tableName, WriterOptions opts)")
	fmt.Fprintln(os.Stderr, "  void update(string writer,  cells)")
	fmt.Fprintln(os.Stderr, "  void flush(string writer)")
	fmt.Fprintln(os.Stderr, "  void closeWriter(string writer)")
	fmt.Fprintln(os.Stderr, "  ConditionalStatus updateRowConditionally(string login, string tableName, string row, ConditionalUpdates updates)")
	fmt.Fprintln(os.Stderr, "  string createConditionalWriter(string login, string tableName, ConditionalWriterOptions options)")
	fmt.Fprintln(os.Stderr, "   updateRowsConditionally(string conditionalWriter,  updates)")
	fmt.Fprintln(os.Stderr, "  void closeConditionalWriter(string conditionalWriter)")
	fmt.Fprintln(os.Stderr, "  Range getRowRange(string row)")
	fmt.Fprintln(os.Stderr, "  Key getFollowing(Key key, PartialKey part)")
	fmt.Fprintln(os.Stderr)
	os.Exit(0)
}

func main() {
	flag.Usage = Usage
	var host string
	var port int
	var protocol string
	var urlString string
	var framed bool
	var useHttp bool
	var parsedUrl url.URL
	var trans thrift.TTransport
	_ = strconv.Atoi
	_ = math.Abs
	flag.Usage = Usage
	flag.StringVar(&host, "h", "localhost", "Specify host and port")
	flag.IntVar(&port, "p", 9090, "Specify port")
	flag.StringVar(&protocol, "P", "binary", "Specify the protocol (binary, compact, simplejson, json)")
	flag.StringVar(&urlString, "u", "", "Specify the url")
	flag.BoolVar(&framed, "framed", false, "Use framed transport")
	flag.BoolVar(&useHttp, "http", false, "Use http")
	flag.Parse()

	if len(urlString) > 0 {
		parsedUrl, err := url.Parse(urlString)
		if err != nil {
			fmt.Fprintln(os.Stderr, "Error parsing URL: ", err)
			flag.Usage()
		}
		host = parsedUrl.Host
		useHttp = len(parsedUrl.Scheme) <= 0 || parsedUrl.Scheme == "http"
	} else if useHttp {
		_, err := url.Parse(fmt.Sprint("http://", host, ":", port))
		if err != nil {
			fmt.Fprintln(os.Stderr, "Error parsing URL: ", err)
			flag.Usage()
		}
	}

	cmd := flag.Arg(0)
	var err error
	if useHttp {
		trans, err = thrift.NewTHttpClient(parsedUrl.String())
	} else {
		portStr := fmt.Sprint(port)
		if strings.Contains(host, ":") {
			host, portStr, err = net.SplitHostPort(host)
			if err != nil {
				fmt.Fprintln(os.Stderr, "error with host:", err)
				os.Exit(1)
			}
		}
		trans, err = thrift.NewTSocket(net.JoinHostPort(host, portStr))
		if err != nil {
			fmt.Fprintln(os.Stderr, "error resolving address:", err)
			os.Exit(1)
		}
		if framed {
			trans = thrift.NewTFramedTransport(trans)
		}
	}
	if err != nil {
		fmt.Fprintln(os.Stderr, "Error creating transport", err)
		os.Exit(1)
	}
	defer trans.Close()
	var protocolFactory thrift.TProtocolFactory
	switch protocol {
	case "compact":
		protocolFactory = thrift.NewTCompactProtocolFactory()
		break
	case "simplejson":
		protocolFactory = thrift.NewTSimpleJSONProtocolFactory()
		break
	case "json":
		protocolFactory = thrift.NewTJSONProtocolFactory()
		break
	case "binary", "":
		protocolFactory = thrift.NewTBinaryProtocolFactoryDefault()
		break
	default:
		fmt.Fprintln(os.Stderr, "Invalid protocol specified: ", protocol)
		Usage()
		os.Exit(1)
	}
	client := proxy.NewAccumuloProxyClientFactory(trans, protocolFactory)
	if err := trans.Open(); err != nil {
		fmt.Fprintln(os.Stderr, "Error opening socket to ", host, ":", port, " ", err)
		os.Exit(1)
	}

	switch cmd {
	case "login":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "Login requires 2 args")
			flag.Usage()
		}
		argvalue0 := flag.Arg(1)
		value0 := argvalue0
		arg230 := flag.Arg(2)
		mbTrans231 := thrift.NewTMemoryBufferLen(len(arg230))
		defer mbTrans231.Close()
		_, err232 := mbTrans231.WriteString(arg230)
		if err232 != nil {
			Usage()
			return
		}
		factory233 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt234 := factory233.GetProtocol(mbTrans231)
		containerStruct1 := proxy.NewAccumuloProxyLoginArgs()
		err235 := containerStruct1.ReadField2(jsProt234)
		if err235 != nil {
			Usage()
			return
		}
		argvalue1 := containerStruct1.LoginProperties
		value1 := argvalue1
		fmt.Print(client.Login(value0, value1))
		fmt.Print("\n")
		break
	case "addConstraint":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "AddConstraint requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		fmt.Print(client.AddConstraint(value0, value1, value2))
		fmt.Print("\n")
		break
	case "addSplits":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "AddSplits requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		arg241 := flag.Arg(3)
		mbTrans242 := thrift.NewTMemoryBufferLen(len(arg241))
		defer mbTrans242.Close()
		_, err243 := mbTrans242.WriteString(arg241)
		if err243 != nil {
			Usage()
			return
		}
		factory244 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt245 := factory244.GetProtocol(mbTrans242)
		containerStruct2 := proxy.NewAccumuloProxyAddSplitsArgs()
		err246 := containerStruct2.ReadField3(jsProt245)
		if err246 != nil {
			Usage()
			return
		}
		argvalue2 := containerStruct2.Splits
		value2 := argvalue2
		fmt.Print(client.AddSplits(value0, value1, value2))
		fmt.Print("\n")
		break
	case "attachIterator":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "AttachIterator requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		arg249 := flag.Arg(3)
		mbTrans250 := thrift.NewTMemoryBufferLen(len(arg249))
		defer mbTrans250.Close()
		_, err251 := mbTrans250.WriteString(arg249)
		if err251 != nil {
			Usage()
			return
		}
		factory252 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt253 := factory252.GetProtocol(mbTrans250)
		argvalue2 := proxy.NewIteratorSetting()
		err254 := argvalue2.Read(jsProt253)
		if err254 != nil {
			Usage()
			return
		}
		value2 := argvalue2
		arg255 := flag.Arg(4)
		mbTrans256 := thrift.NewTMemoryBufferLen(len(arg255))
		defer mbTrans256.Close()
		_, err257 := mbTrans256.WriteString(arg255)
		if err257 != nil {
			Usage()
			return
		}
		factory258 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt259 := factory258.GetProtocol(mbTrans256)
		containerStruct3 := proxy.NewAccumuloProxyAttachIteratorArgs()
		err260 := containerStruct3.ReadField4(jsProt259)
		if err260 != nil {
			Usage()
			return
		}
		argvalue3 := containerStruct3.Scopes
		value3 := argvalue3
		fmt.Print(client.AttachIterator(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "checkIteratorConflicts":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "CheckIteratorConflicts requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		arg263 := flag.Arg(3)
		mbTrans264 := thrift.NewTMemoryBufferLen(len(arg263))
		defer mbTrans264.Close()
		_, err265 := mbTrans264.WriteString(arg263)
		if err265 != nil {
			Usage()
			return
		}
		factory266 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt267 := factory266.GetProtocol(mbTrans264)
		argvalue2 := proxy.NewIteratorSetting()
		err268 := argvalue2.Read(jsProt267)
		if err268 != nil {
			Usage()
			return
		}
		value2 := argvalue2
		arg269 := flag.Arg(4)
		mbTrans270 := thrift.NewTMemoryBufferLen(len(arg269))
		defer mbTrans270.Close()
		_, err271 := mbTrans270.WriteString(arg269)
		if err271 != nil {
			Usage()
			return
		}
		factory272 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt273 := factory272.GetProtocol(mbTrans270)
		containerStruct3 := proxy.NewAccumuloProxyCheckIteratorConflictsArgs()
		err274 := containerStruct3.ReadField4(jsProt273)
		if err274 != nil {
			Usage()
			return
		}
		argvalue3 := containerStruct3.Scopes
		value3 := argvalue3
		fmt.Print(client.CheckIteratorConflicts(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "clearLocatorCache":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "ClearLocatorCache requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.ClearLocatorCache(value0, value1))
		fmt.Print("\n")
		break
	case "cloneTable":
		if flag.NArg()-1 != 6 {
			fmt.Fprintln(os.Stderr, "CloneTable requires 6 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		argvalue3 := flag.Arg(4) == "true"
		value3 := argvalue3
		arg281 := flag.Arg(5)
		mbTrans282 := thrift.NewTMemoryBufferLen(len(arg281))
		defer mbTrans282.Close()
		_, err283 := mbTrans282.WriteString(arg281)
		if err283 != nil {
			Usage()
			return
		}
		factory284 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt285 := factory284.GetProtocol(mbTrans282)
		containerStruct4 := proxy.NewAccumuloProxyCloneTableArgs()
		err286 := containerStruct4.ReadField5(jsProt285)
		if err286 != nil {
			Usage()
			return
		}
		argvalue4 := containerStruct4.PropertiesToSet
		value4 := argvalue4
		arg287 := flag.Arg(6)
		mbTrans288 := thrift.NewTMemoryBufferLen(len(arg287))
		defer mbTrans288.Close()
		_, err289 := mbTrans288.WriteString(arg287)
		if err289 != nil {
			Usage()
			return
		}
		factory290 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt291 := factory290.GetProtocol(mbTrans288)
		containerStruct5 := proxy.NewAccumuloProxyCloneTableArgs()
		err292 := containerStruct5.ReadField6(jsProt291)
		if err292 != nil {
			Usage()
			return
		}
		argvalue5 := containerStruct5.PropertiesToExclude
		value5 := argvalue5
		fmt.Print(client.CloneTable(value0, value1, value2, value3, value4, value5))
		fmt.Print("\n")
		break
	case "compactTable":
		if flag.NArg()-1 != 8 {
			fmt.Fprintln(os.Stderr, "CompactTable requires 8 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := []byte(flag.Arg(3))
		value2 := argvalue2
		argvalue3 := []byte(flag.Arg(4))
		value3 := argvalue3
		arg297 := flag.Arg(5)
		mbTrans298 := thrift.NewTMemoryBufferLen(len(arg297))
		defer mbTrans298.Close()
		_, err299 := mbTrans298.WriteString(arg297)
		if err299 != nil {
			Usage()
			return
		}
		factory300 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt301 := factory300.GetProtocol(mbTrans298)
		containerStruct4 := proxy.NewAccumuloProxyCompactTableArgs()
		err302 := containerStruct4.ReadField5(jsProt301)
		if err302 != nil {
			Usage()
			return
		}
		argvalue4 := containerStruct4.Iterators
		value4 := argvalue4
		argvalue5 := flag.Arg(6) == "true"
		value5 := argvalue5
		argvalue6 := flag.Arg(7) == "true"
		value6 := argvalue6
		arg305 := flag.Arg(8)
		mbTrans306 := thrift.NewTMemoryBufferLen(len(arg305))
		defer mbTrans306.Close()
		_, err307 := mbTrans306.WriteString(arg305)
		if err307 != nil {
			Usage()
			return
		}
		factory308 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt309 := factory308.GetProtocol(mbTrans306)
		argvalue7 := proxy.NewCompactionStrategyConfig()
		err310 := argvalue7.Read(jsProt309)
		if err310 != nil {
			Usage()
			return
		}
		value7 := argvalue7
		fmt.Print(client.CompactTable(value0, value1, value2, value3, value4, value5, value6, value7))
		fmt.Print("\n")
		break
	case "cancelCompaction":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "CancelCompaction requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.CancelCompaction(value0, value1))
		fmt.Print("\n")
		break
	case "createTable":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "CreateTable requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3) == "true"
		value2 := argvalue2
		tmp3, err := (strconv.Atoi(flag.Arg(4)))
		if err != nil {
			Usage()
			return
		}
		argvalue3 := proxy.TimeType(tmp3)
		value3 := argvalue3
		fmt.Print(client.CreateTable(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "deleteTable":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "DeleteTable requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.DeleteTable(value0, value1))
		fmt.Print("\n")
		break
	case "deleteRows":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "DeleteRows requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := []byte(flag.Arg(3))
		value2 := argvalue2
		argvalue3 := []byte(flag.Arg(4))
		value3 := argvalue3
		fmt.Print(client.DeleteRows(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "exportTable":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "ExportTable requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		fmt.Print(client.ExportTable(value0, value1, value2))
		fmt.Print("\n")
		break
	case "flushTable":
		if flag.NArg()-1 != 5 {
			fmt.Fprintln(os.Stderr, "FlushTable requires 5 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := []byte(flag.Arg(3))
		value2 := argvalue2
		argvalue3 := []byte(flag.Arg(4))
		value3 := argvalue3
		argvalue4 := flag.Arg(5) == "true"
		value4 := argvalue4
		fmt.Print(client.FlushTable(value0, value1, value2, value3, value4))
		fmt.Print("\n")
		break
	case "getDiskUsage":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "GetDiskUsage requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		arg331 := flag.Arg(2)
		mbTrans332 := thrift.NewTMemoryBufferLen(len(arg331))
		defer mbTrans332.Close()
		_, err333 := mbTrans332.WriteString(arg331)
		if err333 != nil {
			Usage()
			return
		}
		factory334 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt335 := factory334.GetProtocol(mbTrans332)
		containerStruct1 := proxy.NewAccumuloProxyGetDiskUsageArgs()
		err336 := containerStruct1.ReadField2(jsProt335)
		if err336 != nil {
			Usage()
			return
		}
		argvalue1 := containerStruct1.Tables
		value1 := argvalue1
		fmt.Print(client.GetDiskUsage(value0, value1))
		fmt.Print("\n")
		break
	case "getLocalityGroups":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "GetLocalityGroups requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.GetLocalityGroups(value0, value1))
		fmt.Print("\n")
		break
	case "getIteratorSetting":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "GetIteratorSetting requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		tmp3, err := (strconv.Atoi(flag.Arg(4)))
		if err != nil {
			Usage()
			return
		}
		argvalue3 := proxy.IteratorScope(tmp3)
		value3 := argvalue3
		fmt.Print(client.GetIteratorSetting(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "getMaxRow":
		if flag.NArg()-1 != 7 {
			fmt.Fprintln(os.Stderr, "GetMaxRow requires 7 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		arg344 := flag.Arg(3)
		mbTrans345 := thrift.NewTMemoryBufferLen(len(arg344))
		defer mbTrans345.Close()
		_, err346 := mbTrans345.WriteString(arg344)
		if err346 != nil {
			Usage()
			return
		}
		factory347 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt348 := factory347.GetProtocol(mbTrans345)
		containerStruct2 := proxy.NewAccumuloProxyGetMaxRowArgs()
		err349 := containerStruct2.ReadField3(jsProt348)
		if err349 != nil {
			Usage()
			return
		}
		argvalue2 := containerStruct2.Auths
		value2 := argvalue2
		argvalue3 := []byte(flag.Arg(4))
		value3 := argvalue3
		argvalue4 := flag.Arg(5) == "true"
		value4 := argvalue4
		argvalue5 := []byte(flag.Arg(6))
		value5 := argvalue5
		argvalue6 := flag.Arg(7) == "true"
		value6 := argvalue6
		fmt.Print(client.GetMaxRow(value0, value1, value2, value3, value4, value5, value6))
		fmt.Print("\n")
		break
	case "getTableProperties":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "GetTableProperties requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.GetTableProperties(value0, value1))
		fmt.Print("\n")
		break
	case "importDirectory":
		if flag.NArg()-1 != 5 {
			fmt.Fprintln(os.Stderr, "ImportDirectory requires 5 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		argvalue3 := flag.Arg(4)
		value3 := argvalue3
		argvalue4 := flag.Arg(5) == "true"
		value4 := argvalue4
		fmt.Print(client.ImportDirectory(value0, value1, value2, value3, value4))
		fmt.Print("\n")
		break
	case "importTable":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "ImportTable requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		fmt.Print(client.ImportTable(value0, value1, value2))
		fmt.Print("\n")
		break
	case "listSplits":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "ListSplits requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		tmp2, err366 := (strconv.Atoi(flag.Arg(3)))
		if err366 != nil {
			Usage()
			return
		}
		argvalue2 := int32(tmp2)
		value2 := argvalue2
		fmt.Print(client.ListSplits(value0, value1, value2))
		fmt.Print("\n")
		break
	case "listTables":
		if flag.NArg()-1 != 1 {
			fmt.Fprintln(os.Stderr, "ListTables requires 1 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		fmt.Print(client.ListTables(value0))
		fmt.Print("\n")
		break
	case "listIterators":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "ListIterators requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.ListIterators(value0, value1))
		fmt.Print("\n")
		break
	case "listConstraints":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "ListConstraints requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.ListConstraints(value0, value1))
		fmt.Print("\n")
		break
	case "mergeTablets":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "MergeTablets requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := []byte(flag.Arg(3))
		value2 := argvalue2
		argvalue3 := []byte(flag.Arg(4))
		value3 := argvalue3
		fmt.Print(client.MergeTablets(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "offlineTable":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "OfflineTable requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3) == "true"
		value2 := argvalue2
		fmt.Print(client.OfflineTable(value0, value1, value2))
		fmt.Print("\n")
		break
	case "onlineTable":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "OnlineTable requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3) == "true"
		value2 := argvalue2
		fmt.Print(client.OnlineTable(value0, value1, value2))
		fmt.Print("\n")
		break
	case "removeConstraint":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "RemoveConstraint requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		tmp2, err384 := (strconv.Atoi(flag.Arg(3)))
		if err384 != nil {
			Usage()
			return
		}
		argvalue2 := int32(tmp2)
		value2 := argvalue2
		fmt.Print(client.RemoveConstraint(value0, value1, value2))
		fmt.Print("\n")
		break
	case "removeIterator":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "RemoveIterator requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		arg388 := flag.Arg(4)
		mbTrans389 := thrift.NewTMemoryBufferLen(len(arg388))
		defer mbTrans389.Close()
		_, err390 := mbTrans389.WriteString(arg388)
		if err390 != nil {
			Usage()
			return
		}
		factory391 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt392 := factory391.GetProtocol(mbTrans389)
		containerStruct3 := proxy.NewAccumuloProxyRemoveIteratorArgs()
		err393 := containerStruct3.ReadField4(jsProt392)
		if err393 != nil {
			Usage()
			return
		}
		argvalue3 := containerStruct3.Scopes
		value3 := argvalue3
		fmt.Print(client.RemoveIterator(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "removeTableProperty":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "RemoveTableProperty requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		fmt.Print(client.RemoveTableProperty(value0, value1, value2))
		fmt.Print("\n")
		break
	case "renameTable":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "RenameTable requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		fmt.Print(client.RenameTable(value0, value1, value2))
		fmt.Print("\n")
		break
	case "setLocalityGroups":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "SetLocalityGroups requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		arg402 := flag.Arg(3)
		mbTrans403 := thrift.NewTMemoryBufferLen(len(arg402))
		defer mbTrans403.Close()
		_, err404 := mbTrans403.WriteString(arg402)
		if err404 != nil {
			Usage()
			return
		}
		factory405 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt406 := factory405.GetProtocol(mbTrans403)
		containerStruct2 := proxy.NewAccumuloProxySetLocalityGroupsArgs()
		err407 := containerStruct2.ReadField3(jsProt406)
		if err407 != nil {
			Usage()
			return
		}
		argvalue2 := containerStruct2.Groups
		value2 := argvalue2
		fmt.Print(client.SetLocalityGroups(value0, value1, value2))
		fmt.Print("\n")
		break
	case "setTableProperty":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "SetTableProperty requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		argvalue3 := flag.Arg(4)
		value3 := argvalue3
		fmt.Print(client.SetTableProperty(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "splitRangeByTablets":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "SplitRangeByTablets requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		arg414 := flag.Arg(3)
		mbTrans415 := thrift.NewTMemoryBufferLen(len(arg414))
		defer mbTrans415.Close()
		_, err416 := mbTrans415.WriteString(arg414)
		if err416 != nil {
			Usage()
			return
		}
		factory417 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt418 := factory417.GetProtocol(mbTrans415)
		argvalue2 := proxy.NewRange()
		err419 := argvalue2.Read(jsProt418)
		if err419 != nil {
			Usage()
			return
		}
		value2 := argvalue2
		tmp3, err420 := (strconv.Atoi(flag.Arg(4)))
		if err420 != nil {
			Usage()
			return
		}
		argvalue3 := int32(tmp3)
		value3 := argvalue3
		fmt.Print(client.SplitRangeByTablets(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "tableExists":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "TableExists requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.TableExists(value0, value1))
		fmt.Print("\n")
		break
	case "tableIdMap":
		if flag.NArg()-1 != 1 {
			fmt.Fprintln(os.Stderr, "TableIdMap requires 1 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		fmt.Print(client.TableIdMap(value0))
		fmt.Print("\n")
		break
	case "testTableClassLoad":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "TestTableClassLoad requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		argvalue3 := flag.Arg(4)
		value3 := argvalue3
		fmt.Print(client.TestTableClassLoad(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "pingTabletServer":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "PingTabletServer requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.PingTabletServer(value0, value1))
		fmt.Print("\n")
		break
	case "getActiveScans":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "GetActiveScans requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.GetActiveScans(value0, value1))
		fmt.Print("\n")
		break
	case "getActiveCompactions":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "GetActiveCompactions requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.GetActiveCompactions(value0, value1))
		fmt.Print("\n")
		break
	case "getSiteConfiguration":
		if flag.NArg()-1 != 1 {
			fmt.Fprintln(os.Stderr, "GetSiteConfiguration requires 1 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		fmt.Print(client.GetSiteConfiguration(value0))
		fmt.Print("\n")
		break
	case "getSystemConfiguration":
		if flag.NArg()-1 != 1 {
			fmt.Fprintln(os.Stderr, "GetSystemConfiguration requires 1 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		fmt.Print(client.GetSystemConfiguration(value0))
		fmt.Print("\n")
		break
	case "getTabletServers":
		if flag.NArg()-1 != 1 {
			fmt.Fprintln(os.Stderr, "GetTabletServers requires 1 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		fmt.Print(client.GetTabletServers(value0))
		fmt.Print("\n")
		break
	case "removeProperty":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "RemoveProperty requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.RemoveProperty(value0, value1))
		fmt.Print("\n")
		break
	case "setProperty":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "SetProperty requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		fmt.Print(client.SetProperty(value0, value1, value2))
		fmt.Print("\n")
		break
	case "testClassLoad":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "TestClassLoad requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		fmt.Print(client.TestClassLoad(value0, value1, value2))
		fmt.Print("\n")
		break
	case "authenticateUser":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "AuthenticateUser requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		arg447 := flag.Arg(3)
		mbTrans448 := thrift.NewTMemoryBufferLen(len(arg447))
		defer mbTrans448.Close()
		_, err449 := mbTrans448.WriteString(arg447)
		if err449 != nil {
			Usage()
			return
		}
		factory450 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt451 := factory450.GetProtocol(mbTrans448)
		containerStruct2 := proxy.NewAccumuloProxyAuthenticateUserArgs()
		err452 := containerStruct2.ReadField3(jsProt451)
		if err452 != nil {
			Usage()
			return
		}
		argvalue2 := containerStruct2.Properties
		value2 := argvalue2
		fmt.Print(client.AuthenticateUser(value0, value1, value2))
		fmt.Print("\n")
		break
	case "changeUserAuthorizations":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "ChangeUserAuthorizations requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		arg455 := flag.Arg(3)
		mbTrans456 := thrift.NewTMemoryBufferLen(len(arg455))
		defer mbTrans456.Close()
		_, err457 := mbTrans456.WriteString(arg455)
		if err457 != nil {
			Usage()
			return
		}
		factory458 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt459 := factory458.GetProtocol(mbTrans456)
		containerStruct2 := proxy.NewAccumuloProxyChangeUserAuthorizationsArgs()
		err460 := containerStruct2.ReadField3(jsProt459)
		if err460 != nil {
			Usage()
			return
		}
		argvalue2 := containerStruct2.Authorizations
		value2 := argvalue2
		fmt.Print(client.ChangeUserAuthorizations(value0, value1, value2))
		fmt.Print("\n")
		break
	case "changeLocalUserPassword":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "ChangeLocalUserPassword requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := []byte(flag.Arg(3))
		value2 := argvalue2
		fmt.Print(client.ChangeLocalUserPassword(value0, value1, value2))
		fmt.Print("\n")
		break
	case "createLocalUser":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "CreateLocalUser requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := []byte(flag.Arg(3))
		value2 := argvalue2
		fmt.Print(client.CreateLocalUser(value0, value1, value2))
		fmt.Print("\n")
		break
	case "dropLocalUser":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "DropLocalUser requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.DropLocalUser(value0, value1))
		fmt.Print("\n")
		break
	case "getUserAuthorizations":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "GetUserAuthorizations requires 2 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		fmt.Print(client.GetUserAuthorizations(value0, value1))
		fmt.Print("\n")
		break
	case "grantSystemPermission":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "GrantSystemPermission requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		tmp2, err := (strconv.Atoi(flag.Arg(3)))
		if err != nil {
			Usage()
			return
		}
		argvalue2 := proxy.SystemPermission(tmp2)
		value2 := argvalue2
		fmt.Print(client.GrantSystemPermission(value0, value1, value2))
		fmt.Print("\n")
		break
	case "grantTablePermission":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "GrantTablePermission requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		tmp3, err := (strconv.Atoi(flag.Arg(4)))
		if err != nil {
			Usage()
			return
		}
		argvalue3 := proxy.TablePermission(tmp3)
		value3 := argvalue3
		fmt.Print(client.GrantTablePermission(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "hasSystemPermission":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "HasSystemPermission requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		tmp2, err := (strconv.Atoi(flag.Arg(3)))
		if err != nil {
			Usage()
			return
		}
		argvalue2 := proxy.SystemPermission(tmp2)
		value2 := argvalue2
		fmt.Print(client.HasSystemPermission(value0, value1, value2))
		fmt.Print("\n")
		break
	case "hasTablePermission":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "HasTablePermission requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		tmp3, err := (strconv.Atoi(flag.Arg(4)))
		if err != nil {
			Usage()
			return
		}
		argvalue3 := proxy.TablePermission(tmp3)
		value3 := argvalue3
		fmt.Print(client.HasTablePermission(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "listLocalUsers":
		if flag.NArg()-1 != 1 {
			fmt.Fprintln(os.Stderr, "ListLocalUsers requires 1 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		fmt.Print(client.ListLocalUsers(value0))
		fmt.Print("\n")
		break
	case "revokeSystemPermission":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "RevokeSystemPermission requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		tmp2, err := (strconv.Atoi(flag.Arg(3)))
		if err != nil {
			Usage()
			return
		}
		argvalue2 := proxy.SystemPermission(tmp2)
		value2 := argvalue2
		fmt.Print(client.RevokeSystemPermission(value0, value1, value2))
		fmt.Print("\n")
		break
	case "revokeTablePermission":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "RevokeTablePermission requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := flag.Arg(3)
		value2 := argvalue2
		tmp3, err := (strconv.Atoi(flag.Arg(4)))
		if err != nil {
			Usage()
			return
		}
		argvalue3 := proxy.TablePermission(tmp3)
		value3 := argvalue3
		fmt.Print(client.RevokeTablePermission(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "createBatchScanner":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "CreateBatchScanner requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		arg489 := flag.Arg(3)
		mbTrans490 := thrift.NewTMemoryBufferLen(len(arg489))
		defer mbTrans490.Close()
		_, err491 := mbTrans490.WriteString(arg489)
		if err491 != nil {
			Usage()
			return
		}
		factory492 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt493 := factory492.GetProtocol(mbTrans490)
		argvalue2 := proxy.NewBatchScanOptions()
		err494 := argvalue2.Read(jsProt493)
		if err494 != nil {
			Usage()
			return
		}
		value2 := argvalue2
		fmt.Print(client.CreateBatchScanner(value0, value1, value2))
		fmt.Print("\n")
		break
	case "createScanner":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "CreateScanner requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		arg497 := flag.Arg(3)
		mbTrans498 := thrift.NewTMemoryBufferLen(len(arg497))
		defer mbTrans498.Close()
		_, err499 := mbTrans498.WriteString(arg497)
		if err499 != nil {
			Usage()
			return
		}
		factory500 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt501 := factory500.GetProtocol(mbTrans498)
		argvalue2 := proxy.NewScanOptions()
		err502 := argvalue2.Read(jsProt501)
		if err502 != nil {
			Usage()
			return
		}
		value2 := argvalue2
		fmt.Print(client.CreateScanner(value0, value1, value2))
		fmt.Print("\n")
		break
	case "hasNext":
		if flag.NArg()-1 != 1 {
			fmt.Fprintln(os.Stderr, "HasNext requires 1 args")
			flag.Usage()
		}
		argvalue0 := flag.Arg(1)
		value0 := argvalue0
		fmt.Print(client.HasNext(value0))
		fmt.Print("\n")
		break
	case "nextEntry":
		if flag.NArg()-1 != 1 {
			fmt.Fprintln(os.Stderr, "NextEntry requires 1 args")
			flag.Usage()
		}
		argvalue0 := flag.Arg(1)
		value0 := argvalue0
		fmt.Print(client.NextEntry(value0))
		fmt.Print("\n")
		break
	case "nextK":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "NextK requires 2 args")
			flag.Usage()
		}
		argvalue0 := flag.Arg(1)
		value0 := argvalue0
		tmp1, err506 := (strconv.Atoi(flag.Arg(2)))
		if err506 != nil {
			Usage()
			return
		}
		argvalue1 := int32(tmp1)
		value1 := argvalue1
		fmt.Print(client.NextK(value0, value1))
		fmt.Print("\n")
		break
	case "closeScanner":
		if flag.NArg()-1 != 1 {
			fmt.Fprintln(os.Stderr, "CloseScanner requires 1 args")
			flag.Usage()
		}
		argvalue0 := flag.Arg(1)
		value0 := argvalue0
		fmt.Print(client.CloseScanner(value0))
		fmt.Print("\n")
		break
	case "updateAndFlush":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "UpdateAndFlush requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		arg510 := flag.Arg(3)
		mbTrans511 := thrift.NewTMemoryBufferLen(len(arg510))
		defer mbTrans511.Close()
		_, err512 := mbTrans511.WriteString(arg510)
		if err512 != nil {
			Usage()
			return
		}
		factory513 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt514 := factory513.GetProtocol(mbTrans511)
		containerStruct2 := proxy.NewAccumuloProxyUpdateAndFlushArgs()
		err515 := containerStruct2.ReadField3(jsProt514)
		if err515 != nil {
			Usage()
			return
		}
		argvalue2 := containerStruct2.Cells
		value2 := argvalue2
		fmt.Print(client.UpdateAndFlush(value0, value1, value2))
		fmt.Print("\n")
		break
	case "createWriter":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "CreateWriter requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		arg518 := flag.Arg(3)
		mbTrans519 := thrift.NewTMemoryBufferLen(len(arg518))
		defer mbTrans519.Close()
		_, err520 := mbTrans519.WriteString(arg518)
		if err520 != nil {
			Usage()
			return
		}
		factory521 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt522 := factory521.GetProtocol(mbTrans519)
		argvalue2 := proxy.NewWriterOptions()
		err523 := argvalue2.Read(jsProt522)
		if err523 != nil {
			Usage()
			return
		}
		value2 := argvalue2
		fmt.Print(client.CreateWriter(value0, value1, value2))
		fmt.Print("\n")
		break
	case "update":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "Update requires 2 args")
			flag.Usage()
		}
		argvalue0 := flag.Arg(1)
		value0 := argvalue0
		arg525 := flag.Arg(2)
		mbTrans526 := thrift.NewTMemoryBufferLen(len(arg525))
		defer mbTrans526.Close()
		_, err527 := mbTrans526.WriteString(arg525)
		if err527 != nil {
			Usage()
			return
		}
		factory528 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt529 := factory528.GetProtocol(mbTrans526)
		containerStruct1 := proxy.NewAccumuloProxyUpdateArgs()
		err530 := containerStruct1.ReadField2(jsProt529)
		if err530 != nil {
			Usage()
			return
		}
		argvalue1 := containerStruct1.Cells
		value1 := argvalue1
		fmt.Print(client.Update(value0, value1))
		fmt.Print("\n")
		break
	case "flush":
		if flag.NArg()-1 != 1 {
			fmt.Fprintln(os.Stderr, "Flush requires 1 args")
			flag.Usage()
		}
		argvalue0 := flag.Arg(1)
		value0 := argvalue0
		fmt.Print(client.Flush(value0))
		fmt.Print("\n")
		break
	case "closeWriter":
		if flag.NArg()-1 != 1 {
			fmt.Fprintln(os.Stderr, "CloseWriter requires 1 args")
			flag.Usage()
		}
		argvalue0 := flag.Arg(1)
		value0 := argvalue0
		fmt.Print(client.CloseWriter(value0))
		fmt.Print("\n")
		break
	case "updateRowConditionally":
		if flag.NArg()-1 != 4 {
			fmt.Fprintln(os.Stderr, "UpdateRowConditionally requires 4 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		argvalue2 := []byte(flag.Arg(3))
		value2 := argvalue2
		arg536 := flag.Arg(4)
		mbTrans537 := thrift.NewTMemoryBufferLen(len(arg536))
		defer mbTrans537.Close()
		_, err538 := mbTrans537.WriteString(arg536)
		if err538 != nil {
			Usage()
			return
		}
		factory539 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt540 := factory539.GetProtocol(mbTrans537)
		argvalue3 := proxy.NewConditionalUpdates()
		err541 := argvalue3.Read(jsProt540)
		if err541 != nil {
			Usage()
			return
		}
		value3 := argvalue3
		fmt.Print(client.UpdateRowConditionally(value0, value1, value2, value3))
		fmt.Print("\n")
		break
	case "createConditionalWriter":
		if flag.NArg()-1 != 3 {
			fmt.Fprintln(os.Stderr, "CreateConditionalWriter requires 3 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		argvalue1 := flag.Arg(2)
		value1 := argvalue1
		arg544 := flag.Arg(3)
		mbTrans545 := thrift.NewTMemoryBufferLen(len(arg544))
		defer mbTrans545.Close()
		_, err546 := mbTrans545.WriteString(arg544)
		if err546 != nil {
			Usage()
			return
		}
		factory547 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt548 := factory547.GetProtocol(mbTrans545)
		argvalue2 := proxy.NewConditionalWriterOptions()
		err549 := argvalue2.Read(jsProt548)
		if err549 != nil {
			Usage()
			return
		}
		value2 := argvalue2
		fmt.Print(client.CreateConditionalWriter(value0, value1, value2))
		fmt.Print("\n")
		break
	case "updateRowsConditionally":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "UpdateRowsConditionally requires 2 args")
			flag.Usage()
		}
		argvalue0 := flag.Arg(1)
		value0 := argvalue0
		arg551 := flag.Arg(2)
		mbTrans552 := thrift.NewTMemoryBufferLen(len(arg551))
		defer mbTrans552.Close()
		_, err553 := mbTrans552.WriteString(arg551)
		if err553 != nil {
			Usage()
			return
		}
		factory554 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt555 := factory554.GetProtocol(mbTrans552)
		containerStruct1 := proxy.NewAccumuloProxyUpdateRowsConditionallyArgs()
		err556 := containerStruct1.ReadField2(jsProt555)
		if err556 != nil {
			Usage()
			return
		}
		argvalue1 := containerStruct1.Updates
		value1 := argvalue1
		fmt.Print(client.UpdateRowsConditionally(value0, value1))
		fmt.Print("\n")
		break
	case "closeConditionalWriter":
		if flag.NArg()-1 != 1 {
			fmt.Fprintln(os.Stderr, "CloseConditionalWriter requires 1 args")
			flag.Usage()
		}
		argvalue0 := flag.Arg(1)
		value0 := argvalue0
		fmt.Print(client.CloseConditionalWriter(value0))
		fmt.Print("\n")
		break
	case "getRowRange":
		if flag.NArg()-1 != 1 {
			fmt.Fprintln(os.Stderr, "GetRowRange requires 1 args")
			flag.Usage()
		}
		argvalue0 := []byte(flag.Arg(1))
		value0 := argvalue0
		fmt.Print(client.GetRowRange(value0))
		fmt.Print("\n")
		break
	case "getFollowing":
		if flag.NArg()-1 != 2 {
			fmt.Fprintln(os.Stderr, "GetFollowing requires 2 args")
			flag.Usage()
		}
		arg559 := flag.Arg(1)
		mbTrans560 := thrift.NewTMemoryBufferLen(len(arg559))
		defer mbTrans560.Close()
		_, err561 := mbTrans560.WriteString(arg559)
		if err561 != nil {
			Usage()
			return
		}
		factory562 := thrift.NewTSimpleJSONProtocolFactory()
		jsProt563 := factory562.GetProtocol(mbTrans560)
		argvalue0 := proxy.NewKey()
		err564 := argvalue0.Read(jsProt563)
		if err564 != nil {
			Usage()
			return
		}
		value0 := argvalue0
		tmp1, err := (strconv.Atoi(flag.Arg(2)))
		if err != nil {
			Usage()
			return
		}
		argvalue1 := proxy.PartialKey(tmp1)
		value1 := argvalue1
		fmt.Print(client.GetFollowing(value0, value1))
		fmt.Print("\n")
		break
	case "":
		Usage()
		break
	default:
		fmt.Fprintln(os.Stderr, "Invalid function ", cmd)
	}
}
